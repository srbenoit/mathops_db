package dev.mathops.db.old.logic.mathplan.data;

import dev.mathops.db.old.rawrecord.RawCourse;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashSet;
import java.util.List;
import java.util.Map;

/**
 * A group of {@code CourseInfo} objects generated by a course group.
 */
public final class CourseInfoGroup implements Comparable<CourseInfoGroup> {

    /** The source course group. */
    private CourseGroup courseGroup;

    /** The course information objects, sorted. */
    private final List<CourseInfo> courseInfos;

    /** The number of credits remaining to complete, after completed courses have been removed. */
    private Integer numRemainingCredits;

    /** Flag indicating group has been satisfied by prior work. */
    private boolean satisfied;

    /**
     * Constructs a new {@code CourseInfoGroup}.
     *
     * @param theCourseGroup the source course group
     * @param courseData     a map from course ID to course object
     */
    CourseInfoGroup(final CourseGroup theCourseGroup, final Map<String, RawCourse> courseData) {

        if (theCourseGroup == null) {
            throw new IllegalArgumentException("Course group may not be null");
        }

        this.courseGroup = theCourseGroup;

        final List<String> courseNumbers = theCourseGroup.courseNumbers;
        this.courseInfos = new ArrayList<>(courseNumbers.size());
        for (final String number : courseNumbers) {
            final RawCourse course = courseData.get(number);
            if (course != null) {
                this.courseInfos.add(new CourseInfo(course, false));
            }
        }

        this.numRemainingCredits = theCourseGroup.nbrCredits;
        this.satisfied = false;
    }

    /**
     * Gets the course group on which this object is based.
     *
     * @return the course group
     */
    public CourseGroup getCourseGroup() {

        return this.courseGroup;
    }

    /**
     * Sets the course group.
     *
     * @param theCourseGroup the new source course group
     */
    void setCourseGroup(final CourseGroup theCourseGroup) {

        if (theCourseGroup == null) {
            throw new IllegalArgumentException("Course group may not be null");
        }

        this.courseGroup = theCourseGroup;
    }

    /**
     * Gets the group code.
     *
     * @return the group code
     */
    public String getGroupCode() {

        return this.courseGroup.groupCode;
    }

    /**
     * Gets the list of course information objects.
     *
     * @return the course information objects list
     */
    List<CourseInfo> getCourseInfos() {

        return this.courseInfos;
    }

    /**
     * Gets the list of course numbers.
     *
     * @return the course numbers list
     */
    List<String> getCourseNumbers() {

        return this.courseGroup.courseNumbers;
    }

    /**
     * Gets the number of credits.
     *
     * @return the number of credits; {@code null} if students select a single course from the list
     */
    Integer getNumCredits() {

        return this.courseGroup.nbrCredits;
    }

    /**
     * Gets the remaining number of credits to complete, after credits for completed courses have been removed.
     *
     * @return the actual number of credits; {@code null} if students select a single course from the list
     */
    Integer getNumRemainingCredits() {

        return this.numRemainingCredits;
    }

    /**
     * Sets the remaining number of credits to complete, after credits for completed courses have been removed.
     *
     * @param theNumRemainingCredits the new number of remaining credits; {@code null} if students select a single
     *                               course from the list
     */
    void setNumRemainingCredits(final Integer theNumRemainingCredits) {

        this.numRemainingCredits = theNumRemainingCredits;
    }

    /**
     * Sets the flag that indicates whether the group has been satisfied by placement results, completed courses, and/or
     * transfer credit.
     *
     * @param isSatisfied {@code true} of this group has been satisfied
     */
    public void setSatisfied(final boolean isSatisfied) {

        this.satisfied = isSatisfied;
    }

    /**
     * Tests whether the group has been satisfied by placement results, completed courses, and/or transfer credit.
     *
     * @return {@code true} of this group has been satisfied
     */
    public boolean isSatisfied() {

        return this.satisfied;
    }

    /**
     * Gets the lowest last course (if the lowest possible course numbers are chosen from the list of options, this is
     * the highest course number from that "easiest" list).
     *
     * @return the lowest last course
     */
    String getLowestLastCourse() {

        return this.courseGroup.lowestLastCourse;
    }

    /**
     * Tests whether a set of courses satisfies the requirements of this group.
     *
     * @param courses    the list of courses
     * @param courseData a map from course ID to course data - used to get number of credits for each course
     * @return {@code true} if the course set satisfies this group
     */
    boolean isSatisfiedBy(final Collection<String> courses, final Map<String, RawCourse> courseData) {

        return this.courseGroup.isSatisfiedBy(courses, courseData);
    }

    /**
     * Tests whether satisfying one group will automatically satisfy another. Only groups that require the choice of one
     * course from a list are considered. This method only returns {@code true} of choosing ANY course from such a group
     * will satisfy all requirements of this group.
     *
     * @param groups     the set of course groups (which may contain this group, in which case that item will be
     *                   ignored)
     * @param courseData a map from course ID to course data - used to get number of credits for each course
     * @return {@code true} if the course set satisfies this group
     */
    boolean isSatisfiedByGroup(final Collection<CourseInfoGroup> groups,
                               final Map<String, RawCourse> courseData) {

        final Collection<CourseGroup> set = new HashSet<>(groups.size());
        for (final CourseInfoGroup info : groups) {
            set.add(info.courseGroup);
        }

        return this.courseGroup.isSatisfiedByGroup(set, courseData);
    }

    /**
     * Compares this object with another {@code CourseInfoGroup} for order. Order is based on the lowest course number
     * allowed (compared lexically).
     */
    @Override
    public int compareTo(final CourseInfoGroup o) {

        return this.courseGroup.compareTo(o.courseGroup);
    }

    /**
     * Gets the hash code for the group. The hash code is based only on the group code.
     *
     * @return the hash code
     */
    @Override
    public int hashCode() {

        return getGroupCode().hashCode();

    }

    /**
     * Tests whether another object is equal to this object. To be equal, the other object must be a
     * {@code CourseInfoGroup}, and must have the same group code as this object.
     *
     * @param obj the other object
     * @return {@code true} of the other object is equal to this object
     */
    @Override
    public boolean equals(final Object obj) {

        final boolean equal;

        if (obj instanceof CourseInfoGroup) {
            final String code = getGroupCode();
            equal = ((CourseInfoGroup) obj).getGroupCode().equals(code);
        } else {
            equal = false;
        }

        return equal;
    }

    /**
     * Generates a string representation of the group.
     *
     * @return the string representation
     */
    @Override
    public String toString() {

        return this.courseGroup.toString();
    }
}
